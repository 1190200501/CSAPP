**摘 要**

​		本论文通过hello.c程序，对在CSAPP课程中所学知识进行整理，在Ubuntu虚拟机Linux系统下进行所有操作，运用Linux系统的工具，分析hello程序的一生。

 

**关键词：**hello，计算机系统，linux，程序人生;

 

# 第1章 概述

## 1.1 Hello简介

Hello的P2P过程：

​		在VSCode等编辑器中键入Hello代码得到hello.c程序；对程序进行预处理、编译、汇编、链接生成可执行目标程序；在shell中启动后，shell调用fork创建子进程；hello从Program转换为Process。

 

Hello的020过程：

​		然后shell为hello的execve映射虚拟内存，进入程序入口后开始载入物理内存；进入main函数执行目标代码，CPU为hello分配时间片以执行逻辑控制流；程序运行结束后，shell父进程回收hello进程，释放占用的内存，删除数据结构。

## 1.2 环境与工具

硬件环境

​		X64 CPU；1.6GHz；8G RAM；256G SSD Disk；1T HDD Disk

软件环境

​		Windows10 64位；Vmware 14pro；Ubuntu 20.04.2 LTS 64位

开发工具

​		Visual Studio Code 64位；vim/gpedit+gcc/as/ld/edb/readelf；

## 1.3 中间结果

| 文件的作用                 | 文件名           |
| -------------------------- | ---------------- |
| 预处理后的文件             | hello.i          |
| 编译之后的汇编文件         | hello.s          |
| 汇编之后的可重定位目标文件 | hello.o          |
| 链接之后的可执行目标文件   | Hello            |
| Hello.o  的 ELF 格式       | Elf.txt          |
| Hello.o  的反汇编代码      | Disas_hello.s    |
| hello的ELF 格式            | hello1.elf       |
| hello  的反汇编代码        | hello1_objdump.s |



## 1.4 本章小结

​        本章简要介绍了hello的P2P，020过程，并列出了大作业的软硬件环境及开发工具，还列出了操作过程中产生的中间结果。



# 第2章 预处理

## 2.1 预处理的概念与作用

​        预处理又称预编译，（对于c/c++来说）预处理指的是在程序编译之前，根据以字符#开头的命令（即头文件/define等），修改原始的c程序。

​        预处理的主要作用如下：

​        ● 将源文件中以”include”格式包含的文件复制到编译的源文件中。

​        ● 用实际值替换用“#define”定义的字符串。

​        ● 根据“#if”后面的条件决定需要编译的代码。

## 2.2在Ubuntu下预处理的命令

命令：gcc -E hello.c -o hello.i

![img](file:///C:/Users/lyy/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)

</centre> 图 2.1 预处理命令

 

## 2.3 Hello的预处理结果解析

 

（*以下格式自行编排，编辑时删除*）

## 2.4 本章小结

 

（*以下格式自行编排，编辑时删除*）

 

**（第2章0.5分）**

**
**

# 第3章 编译

## 3.1 编译的概念与作用

 

（*以下格式自行编排，编辑时删除*）

注意：这儿的编译是指从 .i 到 .s 即预处理后的文件到生成汇编语言程序

​    

 

## 3.2 在Ubuntu下编译的命令

 

（*以下格式自行编排，编辑时删除*）

应截图，展示编译过程！

## 3.3 Hello的编译结果解析

 

（*以下格式自行编排，编辑时删除*）

 

此部分是重点，说明编译器是怎么处理C语言的各个数据类型以及各类操作的。应分3.3.1~ 3.3.x等按照类型和操作进行分析，**只要****hello.s****中出现的属于大作业PPT****中P4****给出的参考C****数据与操作，都应解析**。

 

## 3.4 本章小结

 

（*以下格式自行编排，编辑时删除*）

**（第****3****章****2****分）**

**
**

# 第4章 汇编

## 4.1 汇编的概念与作用

 

（*以下格式自行编排，编辑时删除*）

 

注意：这儿的汇编是指从 .s 到 .o 即编译后的文件到生成机器语言二进制程序的过程。

## 4.2 在Ubuntu下汇编的命令

（*以下格式自行编排，编辑时删除*）

应截图，展示汇编过程！

## 4.3 可重定位目标elf格式

  分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。

## 4.4 Hello.o的结果解析

（*以下格式自行编排，编辑时删除*）

objdump -d -r hello.o 分析hello.o的反汇编，并请与第3章的 hello.s进行对照分析。

说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。

## 4.5 本章小结

 

（*以下格式自行编排，编辑时删除*）

**（第****4****章****1****分）**

**
**

# 第5章 链接

## 5.1 链接的概念与作用

（*以下格式自行编排，编辑时删除*）

注意：这儿的链接是指从 hello.o 到hello生成过程。

## 5.2 在Ubuntu下链接的命令

（*以下格式自行编排，编辑时删除*）

使用ld的链接命令，应截图，展示汇编过程！ 注意不只连接hello.o文件

## 5.3 可执行目标文件hello的格式

  分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。

## 5.4 hello的虚拟地址空间

  使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。  

## 5.5 链接的重定位过程分析

（*以下格式自行编排，编辑时删除*）

objdump -d -r hello 分析hello与hello.o的不同，说明链接的过程。

结合hello.o的重定位项目，分析hello中对其怎么重定位的。

## 5.6 hello的执行流程

（*以下格式自行编排，编辑时删除*）

使用edb执行hello，说明从加载hello到_start，到call main,以及程序终止的所有过程。请列出其调用与跳转的各个子程序名或程序地址。

## 5.7 Hello的动态链接分析

  （*以下格式自行编排，编辑时删除*）

分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。

## 5.8 本章小结

 

（*以下格式自行编排，编辑时删除*）

**（第****5****章****1****分）**

 

**
**

# 第6章 hello进程管理

## 6.1 进程的概念与作用

（*以下格式自行编排，编辑时删除*）

## 6.2 简述壳Shell-bash的作用与处理流程

（*以下格式自行编排，编辑时删除*）

## 6.3 Hello的fork进程创建过程

（*以下格式自行编排，编辑时删除*）

## 6.4 Hello的execve过程

（*以下格式自行编排，编辑时删除*）

## 6.5 Hello的进程执行

（*以下格式自行编排，编辑时删除*）

结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。

## 6.6 hello的异常与信号处理

（*以下格式自行编排，编辑时删除*）

 hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。

 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill 等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。

## 6.7本章小结

（*以下格式自行编排，编辑时删除*）

**（第****6****章****1****分）**

**
**

# 第7章 hello的存储管理

## 7.1 hello的存储器地址空间

（*以下格式自行编排，编辑时删除*）

结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。

## 7.2 Intel逻辑地址到线性地址的变换-段式管理

（*以下格式自行编排，编辑时删除*）

## 7.3 Hello的线性地址到物理地址的变换-页式管理

（*以下格式自行编排，编辑时删除*）

## 7.4 TLB与四级页表支持下的VA到PA的变换

（*以下格式自行编排，编辑时删除*）

## 7.5 三级Cache支持下的物理内存访问

（*以下格式自行编排，编辑时删除*）

## 7.6 hello进程fork时的内存映射

（*以下格式自行编排，编辑时删除*）

## 7.7 hello进程execve时的内存映射

（*以下格式自行编排，编辑时删除*）

## 7.8 缺页故障与缺页中断处理

（*以下格式自行编排，编辑时删除*）

## 7.9动态存储分配管理

（*以下格式自行编排，编辑时删除*）

*Printf**会调用malloc**，请简述动态内存管理的基本方法与策略。*

## 7.10本章小结

（*以下格式自行编排，编辑时删除*）

**（第****7****章** **2****分）**

**
**

# 第8章 hello的IO管理

## 8.1 Linux的IO设备管理方法

（*以下格式自行编排，编辑时删除*）

设备的模型化：文件

设备管理：unix io接口

## 8.2 简述Unix IO接口及其函数

（*以下格式自行编排，编辑时删除*）

## 8.3 printf的实现分析

（*以下格式自行编排，编辑时删除*）

https://www.cnblogs.com/pianist/p/3315801.html

从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用 int 0x80或syscall.

字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。

显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。

## 8.4 getchar的实现分析

（*以下格式自行编排，编辑时删除*）

异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。

getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。

## 8.5本章小结

（*以下格式自行编排，编辑时删除*）

**（第****8****章****1****分）**

# 结论

用计算机系统的语言，逐条总结hello所经历的过程。

你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。

**（结论****0****分，缺失** **-1****分，根据内容酌情加分）**

**
**

# 附件

列出所有的中间产物的文件名，并予以说明起作用。

**（附件****0****分，缺失** **-1****分）**

**
**

# 参考文献

**为完成本次大作业你翻阅的书籍与网站等**

[1] 林来兴. 空间控制技术[M]. 北京：中国宇航出版社，1992：25-42.

[2] 辛希孟. 信息技术与信息服务国际研讨会论文集：A集[C]. 北京：中国科学出版社，1999.

[3] 赵耀东. 新时代的工业工程师[M/OL]. 台北：天下文化出版社，1998 [1998-09-26]. http://www.ie.nthu.edu.tw/info/ie.newie.htm（Big5）.

[4] 谌颖. 空间交会控制理论与方法研究[D]. 哈尔滨：哈尔滨工业大学，1992：8-13.

[5] KANAMORI H. Shaking Without Quaking[J]. Science，1998，279（5359）：2063-2064.

[6] CHRISTINE M. Plant Physiology: Plant Biology in the Genome Era[J/OL]. Science，1998，281：331-332[1998-09-23]. http://www.sciencemag.org/cgi/ collection/anatmorp.

**（参考文献****0****分，缺失** **-1****分）**

 